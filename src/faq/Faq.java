package faq;

public class Faq {
    /**
     * горячие клавиши
     * формотирование кода ctrl alt l
     * быстрый комментарий ctrl /
     * множество курсоров alt+shift+ лев кл мыши
     * Обратный таб shift+Tab
     * fori быстрое создание констукции for
     * */
    /**
     * Типы данных:
     *          - Примитивные типы (8 видов) - с маленькой буквы;
     *          Целочисленные (значение по умолчанию 0):
     *          byte - 8 bits (1 bytes), 2 в 8-й степени, значения числа от -128 до 127
     *          short - 16 bits (2 bytes), 2 в 16-й степени, значения числа от -32 768 до 32 767
     *          int - 32 bits (4 bytes), 2 в 32-й степени, значения числа от -2 147 483 648 до 2 147 483 647 (миллиарды)
     *          long - 64 bits (8 bytes), 2 в 64-й степени, значения числа от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 (квинтиллионы)
     *
     *          Дробные или "с плавающей точкой" (значение по умолчанию 0):
     *          float - 32 bits (4 bytes), 3.4*10^38, точность после запятой 7 цифр, {1 bits - знак, 8 bits - порядок, 23 bits - точность}
     *          double - 64 bits (8 bytes), 1.7*10^307, точность после запятой 15 цифр
     *
     *          Логический тип:
     *          boolean - 1 bits (1 bytes), принимает два значения False (ложь) ИЛИ True (истина)
     *
     *          Символьный тип:
     *          char - 16 bits (2 bytes), таблица символов ASCII
     *
     *
     *          - Ссылочные типы (бесконечно много) - с большой буквы
     *          1. Ссылочные типы от JDK (стандартные);
     *          2. Ссылочные типы созданные программистом;
     *          3. Ссылочные типы из интернета созданные другими программистами;
     *
     *          var - https://skillbox.ru/media/base/klyuchevoe-slovo-var-v-java/ вариант динамического определения типа
     * */
    /**Математические операторы:
            "+", "-", "/", "*",
            "++" инкремент (увеличение на 1), х++ постфиксная форма, ++х префиксная форма,
            "--" декремент (уменьшает на 1), х-- постфиксная форма, --х префиксная форма,
            "%" остаток целочисленного деления или деление по модулю,

    Арифметические операции с присваиванием:
            +=   Сложение с присваиванием
         -=     Вычитание с присваиванием
         *=     Умножение с присваиванием
         /=     Деление с присваиванием
         %=     Деление по модулю с присваиванием
         /

                 /Операторы сравнения:

            "==" равно,
            "!=" не равно,
         ">" больше,
            "<" меньше,
            ">=" больше или равно,
            "<=" меньше или равно,
            /

            /Логические операторы:
            "&&" условный И,
         "||" условный ИЛИ,

         &  Логическая операция И (AND) или конъюнкция.
    AND (&) - результат будет true, только если и A, и B равны true.
    Пример: для того чтобы свадьба состоялась, и невеста (A) и жених (B) должны явиться на бракосочетание,
    иначе оно не состоится.

            |  Логическая операция ИЛИ (OR) или дизъюнкция.
    OR (|) - результат будет true, если хотя бы одно значение равно true. Пример: для того, чтобы забрать
    ребенка из садика, должна прийти либо мать, либо отец, либо оба - в любом случае результат будет
    положительный. Если же никто не придет, ребенка не заберут - результат будет отрицательный.

         ^  Логическая операция исключающее ИЛИ (XOR).
    XOR (^) - результат будет true, только если или A равно true, или В равно true. Пример: у двух друзей на
    двоих один велосипед, поездка на велосипеде состоится только если один из них поедет на нем. Вдвоем они
    ехать не могут.

         !  Логическая унарная операция НЕ (NOT).
    NOT (!) - инвертирование значения. Если значение было true, то станет false, и наоборот.

            || Укороченная логическая операция ИЛИ (short-circuit)
         && Укороченная логическая операция И (short-circuit)

         &= Логическая операция И с присваиванием
         |= Логическая операция ИЛИ с присваиванием
         ^= Логическая операция исключающее ИЛИ с присваиванием

    Чаще всего в языке Java используются так называемые укороченные логические операторы (short-circuit):
            ||   -  Укороченный логический оператор ИЛИ
         &&  - Укороченный логический оператор И
    Правый операнд сокращенных операций вычисляется только в том случае, если от него зависит результат операции,
    то есть если левый операнд конъюнкции имеет значение true, или левый операнд дизъюнкции имеет значение false.
    В формальной спецификации языка Java укороченные логические операции называются условными.
    В следующем примере правый операнд логического выражения вычисляться не будет, так как условие num8!=0
    не выполняется и нет смысла дальше вычислять это выражение:
            */

    /**быстрое копирование строки cntrl d*/
/**
 * psvm public static void main(String[] arg
 * sout- System.out.println();*/

/**Конструкция if
 if (Если первое условие ДА) {
 Тогда выполняется тело с кодом 1
 } else if (Если второе условие ДА) {
 Тогда выполняется тело с кодом 2
 } else {
 Во всех прочих условиях выполняется тело с кодом 3
 }
 */
/**Конструкция Switch
 switch(значение3){
 case значение1:
 Выполняющийся код;
 break; //остановка switch
 case значение2:
 Выполняющийся код;
 break; //остановка switch
 case значение3:
 Выполняющийся код;
 break; //остановка switch
 default:
 Выполняющийся код, если значение не верное;
 }
 */
/**
 * ГОРЯЧИЕ КЛАВИШИ
 * Форматирование кода Ctrl+Alt+L
 * Быстрый комментарий Ctrl+/
 * Быстрое копирование строки без выделения Ctrl+D
 * Множество курсоров Alt+Shift+ЛКМ
 * Обратный Tab Shift+Tab
 *
 * Редактирование:*
 * Ctr + Z  Undo, отменить последнее действие
 * Ctr + Shift + Z  Redo, отменить последнюю отмену действия
 * Ctr + Shift + V  Расширенная вставка из буфера обмена (с историей)
 * Ctr (+ Shift) + W  Инкрементальное выделение выражения
 * Ctr + влево/вправо  Перемещение между словами
 * Ctr + вверх/вниз  Прокрутка кода без изменения позиции курсора
 * Ctr + Home/End  Переход в начало/конец файла
 * Shift + Del (Ctr + Y)  Удаление строки, отличие в том, где потом окажется курсор
 * Ctr + Del  Удалить от текущей позиции до конца слова
 * Ctr + Backspace  Удалить от текущей позиции до начала слова
 * Ctr + D  Дублировать текущую строку
 * Tab / Shift + Tab  Увеличить / уменьшить текущий отступ
 * Ctr + Alt + I  Выравнивание отступов в коде
 * Ctr + Alt + L  Приведение кода в соответствие code style
 * Ctr + /  Закомментировать/раскомментировать текущую строку
 * Ctr + Shift + /  Закомментировать/раскомментировать выделенный код
 * Ctr + -/+  Фолдинг, свернуть/развернуть
 * Ctr + Shift + -/+  Фолдинг, свернуть/развернуть все
 * Ctr + Shift + .  Сделать текущий скоуп сворачиваемым и свернуть его
 * Ctr + .  Сделать текущий скоуп несворачиваемым
 * Ctr + R  Замена в тексте
 * Ctr + Shift + R  Замена во всех файлах
 *
 *
 * Окна, вкладки:*
 * Alt + влево/вправо  Перемещение между вкладками
 * Ctr + F4  Закрыть вкладку
 * Alt + циферка  Открытие/закрытие окон Project, Structure, Changes и тд
 * Ctr + Tab  Switcher, переключение между вкладками и окнами
 * Shift + Esc  Закрыть активное окно
 * F12  Открыть последнее закрытое окно
 * Ctr + колесико  Zoom, если он был вами настроен
 *
 *
 * Закладки:*
 * F11  Поставить или снять закладку
 * Ctr + F11  Аналогично с присвоением буквы или цифры
 * Shift + F11  Переход к закладке (удаление — клавишей Delete)
 * Ctr + Число  Быстрый переход к закладке с присвоенным числом
 *
 *
 * Подсказки и документация:*
 * Ctr + Q  Документация к тому, на чем сейчас курсор
 * Ctr + Shift + I  Показать реализацию метода или класса
 * Alt + Q  Отобразить имя класса или метода, в котором мы находимся
 * Ctr + P  Подсказка по аргументам метода
 * Ctr + F1  Показать описание ошибки или варнинга
 * Alt + Enter  Показать, что нам предлагают «лампочки»
 *
 *
 * Поиск:*
 * Дважды Shift  Быстрый поиск по всему проекту
 * Ctr + Shift + A  Быстрый поиск по настройкам, действиям и тд
 * Alt + вниз/вверх  Перейти к следующему/предыдущему методу
 * Ctr + [ и Ctr + ]  Перемещение к началу и концу текущего скоупа
 * Ctr + F  Поиск в файле
 * Ctr + Shift + F  Поиск по всем файлам (переход — F4)
 * Ctr + F3  Искать слово под курсором
 * F3 / Shift + F3  Искать вперед/назад
 * Ctr + G  Переход к строке или строке:номеру_символа
 * Ctr + F12  Список методов с переходом к их объявлению
 * Ctr + E  Список недавно открытых файлов с переходом к ним
 * Ctr + Shift + E  Список недавно измененных файлов с переходом к ним
 * Ctr + H  Иерархия наследования текущего класса и переход по ней
 * Ctr + Alt + H  Иерархия вызовов выбранного метода
 * Ctr + N  Поиска класса по имени и переход к нему
 * Ctr + Shift + N  Поиск файла по имени и переход к нему
 * Ctr + B  Перейти к объявлению переменной, класса, метода
 * Ctr + Alt + B  Перейти к реализации
 * Ctr + Shift + B  Определить тип и перейти к его реализации
 * Shift + Alt + влево  Перемещение назад по стеку поиска
 * Shift + Alt + вправо  Перемещение вперед по стеку поиска
 * F2 / Shift + F2  Переход к следующей / предыдущей ошибке
 * Shift + Alt + 7  Найти все места, где используется метод / переменная
 * Ctr + Alt + 7  Как предыдущий пункт, только во всплывающем окне
 *
 *
 * Генерация кода и рефакторинг:*
 * Ctr + Space  Полный автокомплит
 * Ctr + Shift + Space  Автокомплит с фильтрацией по подходящему типу
 * Alt + /  Простой автокомплит по словам, встречающимся в проекте
 * Ctr + I  Реализовать интерфейс
 * Ctr + O  Переопределить метод родительского класса
 * Ctr + J  Генерация шаблонного кода (обход по итератору и тд)
 * Ctr + Alt + J  Обернуть выделенный код в один из шаблонов
 * Alt + Insert  Генератор кода — сеттеров, зависимостей в pom.xml и тд
 * Shift + F6  Переименование переменной, класса и тд во всем коде
 * Ctr + F6  Изменение сигнатуры метода во всем коде
 * F6  Перемещение метода, класса или пакета
 * F5  Создать копию класса, файла или каталога
 * Shift + F5  Создать копию класса в том же пакете
 * Alt + Delete  Безопасное удаление класса, метода или атрибута
 * Ctr + Alt + M  Выделение метода
 * Ctr + Alt + V  Выделение переменной
 * Ctr + Alt + F  Выделение атрибута
 * Ctr + Alt + C  Выделение константы (public final static)
 * Ctr + Alt + P  Выделение аргумента метода
 * Ctr + Alt + N  Инлайнинг метода, переменной, аргумента или константы
 * Ctr + Alt + O  Оптимизация импортов
 *
 *
 * Прочее:*
 * Ctr + ~  Быстрое переключение цветовой схемы, code style и тд
 * Alt + F12  Открыть/закрыть терминал
 * F10  Запустить последнюю запущенную программу или тест
 * Shift + F10  Запустить открытую в редакторе программу или тест
 * Shift + Alt + F10  Запустить что-то из списка того что запускалось раньше
 * Ctr + F2  Остановить программу
 * Ctr + Alt + A  Добавить в систему контроля версий
 * Ctr + K  Сделать коммит в систему контроля версий
 * Ctr + Shift + K  Сделать пуш в систему контроля версий
 * Ctr + Shift + P  В Scala-плагине определяет implicit параметры
 * Ctr + Shift + Q  В Scala-плагине определяет implicit преобразования
 *
 *
 * */

/**Циклы
    Циклы - то, что заставляет повторяться код определенное кол-во раз, пока выполняется условие
    Три формата циклов в java: for foreach while

            for(инициация;условие;итерация){
        тело цикла
    }
 if мб без else и одна строчка кода можно без {}
 if(условие ) /// код если true
 ------------------
 if(true){}
 for(инициализация; условие; итерация){
  тело цикла
 }
 /for(1;2;3){         1, потом 4,3,2, потом 4,3,2, потом 4,3,2 и так пока 2=true, если false то выход из цикла
 System.out.println("Тело цикла 4");
 }
 /
 */
/** Массивы - группировка примитивных типов
 Массив - это группа примитивных типов. В массив можно положить только однотипные данные.
 Массив имеет индексы от 0 и выше, каждое значение записывается в ячейку памяти имеющую  индекс.

 /**заполнение по умолчанию, когда нет значений
  * int - 0
  * double - 0.0
  * boolean - false
  * Сcылочные типы - null
  * /

/** Группировка примитивных типов
    Массив - это группа примитивных типов. В массив можно положить только однотипные данные.
    Массив имеет индексы от 0 и выше, каждое значение записывается в ячейку памяти имеющую  индекс.
 заполнение по умолчанию, когда нет значений
 int - 0
 double - 0.0
 boolean - false
 Сcылочные типы - null

 /for each - удобен, если нужно пройтись просто с лево на право
 * и по каждой ячейке с шагом 1. При этом не нужны индексы.
 * Например, нужно просто вывести на консоль все значения массива от 1 до последнего
 for (переменная :имя массива){
 Выполняемый код
 }
 /
         */
/**Ссылочные типы от JDK (стандартные):
 *          java.util - множество безразмерных массивов
 *          java.time - работа со временем
 *          java.text - работа с текстом
 *          java.sql - работа с базой данных
 *          java.security - работа по безопасности
 *          java.io, java.nio - копирование и перемещение файлов
 *          java.math - математические функции
 *          java.lang - стандартный набор для каждого создаваемого класса по работе с клавиатурой,
 *          календарем, String и т.п. Здесь и лежит метод System.in и System.out
 *          java.net - работа с сетью
 *          java.awt - старая технология рисования графических элементов
 *          java.applet - методы открытия и работы приложений через браузер
 *          /
 *          Сcылочные типы - null
 *      * /
 * /
 *          * Методы класса String:
 *          *    int lenght() - возвращает длину строки (количество символов в строке);
 *          *
 *          *    String concat(String s) - присоединяет строку к строке this. Работает как +;
 *          *
 *          *    String trim() - удаляет ведущие и завершающие пробельные символы из строки this
 *          *                    Пробельные символы: ' ', \r, \n, \t. Например, при вводе пароля отброс пробелов;
 *          *
 *          *    String replace(char original, char replacement) - заменяет все вхождения символа original символом
 *          *                    replacement;
 *          *
 *          *    String toLowerCase() - изменяет регистр символов в строке, делая все буквы строчными. Например,
 *          *                    преобразование e-mail к маленьким буквам всегда;
 *          *
 *          *    String toUpperCase() - изменяет регистр символов в строке, делая все буквы прописными;
 *          *
 *          *    String replaceAll(String regex, String replacement) - замещает все вхождения regex на replacement.
 *          *                    В качестве regex может быть регулярное выражение. Например, есть текст поздравления
 *          *                    на Дмитрия, можно во всем письме заменить Дмитрия на Петра;
 *          *
 *          *    String replaceFirst(String regex, String replacement) - замещает первое вхождения regex на replacement.
 *          *                    В качестве regex может быть регулярное выражение. Например, есть письмо и в нем обращение
 *          *                    есть к адресату есть только один раз, значит можно после замены адресата дальше не
 *          *                    проверять текст на поиск старого адресата;
 *          *
 *          *    boolean equals(Object other) - производит посимвольное сравнение строки this со строкой other с учетом
 *          *                    регистра символов. Оператор == работает только на примитивные типы, ана сылочные типы
 *          *                    работает equals;
 *          *
 *          *    boolean equalsIgnoreCase(String other) - производит посимвольное сравнение строки this со строкой other
 *          *                    без учета регистра символов;
 *          *
 *          *   boolean regionMatches(int startIndex, String other, int otherStartIndex, int numChars) - сравнивает между
 *          *                    собой два участка строк this и other с учетом регистра символов;
 *          *
 *          *   boolean regionMatches(boolean ignoreCase, int startIndex, String other, int otherStartIndex, int numChars)
 *          *                    - сравнивает между собой два участка строк this и other без учетом регистра символов;
 *          *
 *          /
 *
 *          Сcылочные типы - null
 *      * /
 * /
 *          * Методы класса String:
 *          *    int lenght() - возвращает длину строки (количество символов в строке);
 *          *
 *          *    String concat(String s) - присоединяет строку к строке this. Работает как +;
 *          *
 *          *    String trim() - удаляет ведущие и завершающие пробельные символы из строки this
 *          *                    Пробельные символы: ' ', \r, \n, \t. Например, при вводе пароля отброс пробелов;
 *          *
 *          *    String replace(char original, char replacement) - заменяет все вхождения символа original символом
 *          *                    replacement;
 *          *
 *          *    String toLowerCase() - изменяет регистр символов в строке, делая все буквы строчными. Например,
 *          *                    преобразование e-mail к маленьким буквам всегда;
 *          *
 *          *    String toUpperCase() - изменяет регистр символов в строке, делая все буквы прописными;
 *          *
 *          *    String replaceAll(String regex, String replacement) - замещает все вхождения regex на replacement.
 *          *                    В качестве regex может быть регулярное выражение. Например, есть текст поздравления
 *          *                    на Дмитрия, можно во всем письме заменить Дмитрия на Петра;
 *          *
 *          *    String replaceFirst(String regex, String replacement) - замещает первое вхождения regex на replacement.
 *          *                    В качестве regex может быть регулярное выражение. Например, есть письмо и в нем обращение
 *          *                    есть к адресату есть только один раз, значит можно после замены адресата дальше не
 *          *                    проверять текст на поиск старого адресата;
 *          *
 *          *    boolean equals(Object other) - производит посимвольное сравнение строки this со строкой other с учетом
 *          *                    регистра символов. Оператор == работает только на примитивные типы, ана сылочные типы
 *          *                    работает equals;
 *          *
 *          *    boolean equalsIgnoreCase(String other) - производит посимвольное сравнение строки this со строкой other
 *          *                    без учета регистра символов;
 *          *
 *          *   boolean regionMatches(int startIndex, String other, int otherStartIndex, int numChars) - сравнивает между
 *          *                    собой два участка строк this и other с учетом регистра символов;
 *          *
 *          *   boolean regionMatches(boolean ignoreCase, int startIndex, String other, int otherStartIndex, int numChars)
 *          *                    - сравнивает между собой два участка строк this и other без учетом регистра символов;
 *          *
 *          /
 */
/**
 --Методы--
 Название класса (файла) должно четко отвечать на вопрос какие в нем собраны методы. Методы лучше разбивать по
 смыслам на разные классы (файлы), не должны быть все методы собраны в одном классе;

 --Формула создания метода--
 *      1 - модификатор доступа - это одно из 4-х видов слов, указывается перед методом или классом:
 *      *     public - метод/класс будет доступен внутри всех пакетов всего проекта (99% случаев используется);
 *      *     protected - внутри пакета и его наследникам, то есть дочерним классам, расположенных в других пакетах в данном проекте;
 *      *     ______ - будет доступен только внутри текущего пакета (текущей папки);
 *      *     private - только внутри текущего класса (файла);
 *
 *      2 - Статичность - два варианта: может быть указан признак статичности, либо нет:
 *      *     ______ - не static, если метод будет вызываться у переменной text.split(" ");, то он не должен быть static;
 *      *     static - если метод будет вызываться у типа String.copyValueOf(char[] data);
 *
 *      3 - Возвращаемый тип или слово void если метод ни чего не возвращает:
 *      *     public static int - если метод будет возвращать число;
 *      *     public static char[] - если возвращает массив символов;
 *      *     public static String - если возвращает строку;
 *      *     public static ****** - прочие варианты возвращаемых типов;
 *      *     public static void - если ни чего не возвращает, а просто выполняется, например, печать на консоль;
 *
 *      4 - Название метода: поясняющее его суть, с маленькой буквы;
 *
 *      5 - Входящие параметры в круглых скобках один или много через запятую с указанием типа
 *
 *      6 - тело метода (то что должно происходить, когда метод вызовут);
 *
 *          public static void        printMassiveToConsole(int[][] mass)
 *      Модификаторы доступа метода        Сигнатура метода
 */
/** ООП - основные парадигмы:
 *  1. Инкапсуляция - скрытие данных от других классов или структур кода, область видимости кода. Реализована через модификаторы доступа
 *                      - public;
 *                      - protected;
 *                      - _________;
 *                      - private;
 *      Модификатор доступа ставится у Класса и его составляющих. Класс состоит из: Полей; Конструкторы; Методов.
 *
 *  2.
 * */
/** ООП - объектно-ориентированное программирование. Основные принципы:
         *  1. Инкапсуляция - область видимости, реализована через модификаторы доступа:
         *      public - метод/класс будет доступен внутри всех пакетов всего проекта (99% случаев используется);
         *      protected - внутри пакета и его наследникам, то есть дочерним классам, расположенных в других пакетах в данном проекте;
         *      ______ - будет доступен только внутри текущего пакета (текущей папки);
         *      private - только внутри текущего класса (файла);
         *   2. Наследование - extends — это механизм, который позволяет создавать классы на основе
         *      других классов наследую их методы в дочерних (подчиненных) классах.
         *   3. Абстракция - означает выделение главных, наиболее значимых характеристик предмета и
         *      наоборот — отбрасывание второстепенных, незначительных.
         *   4. Полиморфизм - это способность программы идентично использовать объекты с одинаковым
         *      интерфейсом без информации о конкретном типе этого объекта. Мы можем работать со
         *      многими типами, как с одним (при условии, что эти типы являются производными (дочерними)
         *      от базового (разового) типа).
         *
         *
         */
/**
 Object
 |
 ________ _________________Человек________________________
 |                 (бегать, прыгать, говорить)             |
 |                                                         |
 Ученик  extends Человек                                  Работник extends Человек
 (бегать, прыгать, говорить) + (учиться)                    (бегать, прыгать, говорить) + (работать)

 Для проверки можно ли наследоваться слово extends нужно заменить на "ЯВЛЯЕТСЯ ЛИ", при однозначном ДА можно наследоваться.
 Если создать массив Человек[] люди = new Человек[5]; Тогда в нем можно хранить объекты
 подчиненных классов Ученик и Работник, а также ниже по иерархии, например ученик может делиться на первоклассников
 и старшеклассников.

 Наши классы AudioContent и DiscVideo сейчас ни как не связаны, но на самом деле связь есть.
 ______________Object____________
 |                               |
 AudioContent                       VideoContent
 Object - это класс по умолчанию, который всегда вверху иерархии и имеет некоторое количество общих методов.

 */
/**

 ctrl+p в скобках можно нажать для подсказки
 */
/**
  * Формула конструктора:
  * модификатор доступа + Возвращаемый тип класса(){}
     *
     * Нельзя создать конструкторы так:
     * public Table(int length, int width, int height){}
     * public Table(int width, int length, int height){}
     *
     * Нельзя создать конструкторы так:
 * public Table(int length, int height){}
     * public Table(int length, int width){}
     *
             * Проверка дублей конструкторов происходит по количеству и по типам входящих параметров
     *
             *
             * /
             *      * главное отличие между this и super в Java в том, что this представляет текущий экземпляр класса,
     *      * в то время как super - текущий экземпляр родительского класса.
         *
         *     public IronTable(){
     *         super.;
     *         this.
          *     }

     */
/**
 * Виды классов:
 * Класс - содержит поля, конструкторы и методы
 * Абстрактный класс - как обычный класс, но в сигнатуре добавляется слово abstract
 *                   - в нем могут быть абстрактные методы, могут не быть (под реализацию в других типах, пример аудио и видео)
 *                   -  из-за неопределенности абстрактных методов мы теряем возможность создать его объект.
 *
 * Интерфейс - такой же, как обычный класс, но мы не можем создать его объект
 *           - все методы только абстрактные
 *           - все поля public static final. static - общая, final - не изменяемые
 *           Интерфейс - это как требования, например
 *           _________ Samsung______________________________
 *     Фотокамера               Файловый менеджер         Органайзер
 *     - Сделать фото           - Удалить файл
 *     - Сделать видео          - Переименовать файл
 *                              - Переместить файл
 *     Если класс - это как техническая документация к будущему объекты.
 *     То интерфейс  - как тех. задание к техническому проекту (документации)
 *
 * Interface — ключевое слово для создания интерфейса в Java
 * Создать экземпляр интерфейса в Java нельзя
 * Интерфейс обеспечивает абсолютную абстракцию
 * Интерфейсы не могут иметь конструкторов, потому что мы не можем создать экземпляр/объект интерфейса
 * По умолчанию любой атрибут интерфейса является public, static и final, так что нам не нужно определять модификаторы доступа к атрибутам
 * По умолчанию методы интерфейса неявно abstract и public
 * Интерфейс в Java не может быть подклассом у другого класса, но он может реализовать другой интерфейс
 * Ключевое слово implements используется классами для реализации интерфейса
 * Класс, реализующий интерфейс, должен обеспечить реализацию всех его метода, если только это не абстрактный класс
 *
 * Enum
 * Внутренний безымянный класс
 * Анонимный класс
 */
/**
        *  Интерфейс: Collection
         *  Коллекция - это массив с неограниченным размером и хранящий любые типы данных, но одного типа в одной коллекции
         *  До версии JDK 1.5 все коллекции были подчинены Object, и поэтому одна коллекция могла хранить разные типы
         *  данных, но не могла иметь разные методы свойственные типам и поэтому после от этого отказались и все коллекции
         *  стали содержать только один тип.
         *
                 *       Интерфейсы коллекций: Collection и Map (находятся на одном уровне, т.е. друг с другом не связаны)
         *                             Collection - группы объектов;
         *                             Map - массив объектов по ассоциациям;
         *
                 *                                      (Interface)
            *                                        Iterable (повторяемый или перебираемый) содержит Iterator<T> iterator();
         *                                           |
                 *                                      (Interface)
            *               __________________java.util.Collection _________________________
         *              |                                                               |
                 *          (Interface)                                                     (Interface)
            *      java.util.Set (Сумка)                                             java.util.List (Записная книжка)
            *      - Все значения уникальны;                                          - Могут хранится дубликаты значений;
         *      - Нет индексов;                                                    - Индексы есть;
         *      - Нет порядка вхождения;                                           - Есть порядок вхождения;
         *                  |                                                                        |
                 *     _____________|_______________                                         ________________|___________________
         *     |                           |                                         |                                  |
                 * (Interface)                HashSet                                   ArrayList                         LinkedList
         * SortedSet                - Элементы не упорядочены                 (ас.пронумерованный список)       (ас.живая очередь)
            *     |                    - Может хранить NULL – значения          - Добавление долго              - Добавление быстрое
         * (Interface)              - Порядок задает HashCode                - Удаление долго                - Удаление быстрое
         * NavigableSet                            |                         - Читать быстро                 - Читать дольше
         *     |                                   |                        ___________________              ___________________
         *     |                                   |                         - Добавление редкое;            - Добавление частое;
         *     |                                   |                         - Удаление редкое;              - Удаление частое;
         *     |                                   |                         - Чтение частое;                - Чтение условно редкое;
         *     |                                   |
                 *  TreeSet                          LinkedHashSet
         * (дерево значений)                  - Есть порядок вхождения
         * (двоичное  дерево)
            * (не просто двоичное дерево)
            * (меньше на лево, больше на право)
            * (сортировка - компарабл метод компероту)
            */
            /**
            *  Интерфейс: Map
         *  Коллекция - это массив с неограниченным размером и хранящий любые типы данных, но одного типа в одной коллекции
         *  До версии JDK 1.5 все коллекции были подчинены Object, и поэтому одна коллекция могла хранить разные типы
         *  данных, но не могла иметь разные методы свойственные типам и поэтому после от этого отказались и все коллекции
         *  стали содержать только один тип.
         *
                 *       Интерфейсы коллекций: Collection и Map (находятся на одном уровне, т.е. друг с другом не связаны)
         *                             Collection - группы объектов;
         *                             Map - массив объектов по ассоциациям, хранящий ключ и значения;
         *      Дубликаты по значению могут быть, а по ключу не могут быть. Ключ всегда уникальный.
         *
                 *      Интерфейс: Map
         *          *          - Map - у интерфейса Map есть реализация HashMap<K, V>, его еще называют массив по ассоциациям
         *          *              K - Тип ключа (любой ссылочный тип)
         *          *              V - Тип значения (любой ссылочный тип)
         *          *              Пример турнирная таблица: | Динамо | Шахтер | Спартак | - это ключ вместо индексов (уникальный)
         *          *                                        |   5    |  4     |   3     | - это значение (не уникальные)
         *          *
                 *          *              В данном примере тип ключа String, тип значения Integer, но типы могут быть любые.
            *          *
            *          *              Примитивные типы нельзя хранить внутри коллекций! Для этого есть ссылочные типы примитивов:
            *          *                  int    -  Integer
         *          *                  byte   -  Byte
         *          *                  short  -  Short
         *          *                  char   -  Character
         *          *       Пример коллекции типа HashMap standings - турнирная таблица, ниже:
            *
            *      Некоторые источники говорят о том что Map это не коллекция, а ассоциативный массив, где индексом
         *      выступает ключ - данные любого типа приведенные к int. Однако Герберт Шилдт Java полное руководство
         *      называет Map коллекциями.
         *      Примеры использования Map, там где есть список состоящий из пары значений, например:
            *          - ТурнирнаяТаблица<K-команда,V-очки>
            *          - Рецепты<K-ингредиент,V-количество>
            *          - ИгральныеКарты<K-карта,V-значение>
            *          - КаталогТоваров <K-карточка номенклатуры товара,V-розничная цена>
            *       При чем ключ не просто числовой идентификатор, он и так есть в виде индексов или хэшкодов, а именно
         *       полезный тип данных в ключе. Тогда например при сортировке по ключу, произойдет и сортировка по
         *       значению. Если такой задачи нет, тогда можно использовать не парные коллекции Set или List.
            *       Ключ принимает любой ссылочный тип, если нужны примитивы то классы обертки, и значение принимает
         *       любой тип, а так же можно положить целую коллекцию и связать с ключом.
            *
            *                                       (Interface)
            *                                        Iterable (повторяемый или перебираемый) содержит Iterator<T> iterator();
         *                                           |
                 *                                      (Interface)
            *                    __________________java.util.Map <ключ, значение> _______________________
         *                   |                            |                                           |
                 *             (Interface)                     HashMap                                      HashTable (Считается устаревшей)
         *              SortedMap                 - нет порядка вхождения
         *                  |                     - ключ может быть == Null,
            *             (Interface)                  но один раз.
         *            NavigableMap                - есть hashCode (меняется при расширении)
         *                   |                    - new HashMap<>(16,0.75f)
                 *                TreeMap                 -
            *            - есть сортировка<K,V>
         *                                                 |
                 *                                                 |
                 *                                           LinkedHashMap
*                                        - есть порядка вхождения
         *
                 *
                 *
                 *
                 */

    /**
     * Git - это система контроля версий
     * Требуется облачное хранение кода для доступа на различных устройствах из разных место, а также для хранения
     * версия, для сравнения кода, работа нескольких разработчиков в одном проекте.
     *
     * Для этих целей придуман git.
     *
     * Git - это система контроля версий. Контролируются изменения в одном или нескольких файлах, и предоставляет
     *  возможность вернуться на прежнюю версию файла. А также предоставляет возможность работать над одной
     * программой группе программистов, совмещая код, показывая разницы и историю разработки.
     * Есть разные сервисы:
     *      svn/subversion (бесплатный, свободная централизованная система управления версиями, официально
     *          выпущенная в 2004 году в США компанией CollabNet);
     *      git - локальный репозиторий:
     *      gitHub (условно-бесплатный, официально принадлежит корпорации Microsoft);
     *      gitLab (условно-бесплатный, основали выходцы из Украины Валерий Сизов и Дмитрий Запорожец в 2011 году,
     *          в 2013 году к ним присоединился Сид Сибранджи);
     *
     * Репозиторий - это место хранения кода, изначально локально и далее отправляться в облако (web-server).
     * У одного аккаунта git, может быть много репозиториев.
     *
     * Ы резюме всегда нужно указывать ссылку на свой git репозиторий или github или чаще gitlab, где работодатель
     * может изучить ваши проекты.
     *
     * Схема работы:
     *                                              Репозиторий
     *                          _________________________________________________
     *                          |      Код, например интернет-магазина          |
     *                 _______  |_______________________________________________|?------
     *         Update |     Push  ?         |        ?                  |              |
     *               1|          2|       1 |       2|                 1|            2 |
     *         _______?_______   |      ___?________|______       _____?______________|__
     *         |       commit|____|     |                 |        |                    |
     *         | Авторизация |          | Новая страница  |        | Отладка коннектора |
     *         |_____________|          |_________________|        |____________________|
     *           Компьютер 1               Компьютер 2              Компьютер 3
     *
     * 1. Update - (обновить) скачать из облака обновления (push коллег)
     * 2. Commit - (фиксировать) сохранить в локальный git
     * 3. Push - (затолкать) сохранить в облачный git
     */
    /**
     * ПОЛЕЗНЫЕ ССЫЛКИ
     * 1. Книга о GIT, в том числе на русском: https://git-scm.com/book/ru/v2
     * 2. Ссылка на терминал: https://git-scm.com/downloads
     * 3. Обучение git: https://learngitbranching.js.org/?locale=ru_RU
     */
 }
