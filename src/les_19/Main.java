package les_19;

public class Main {
    public static void main(String[] args) {

        /**
         * 1. Создаем интерфейс Печатной продукции Printable c методом void print();
         *
         * Механизм наследования очень удобен, но он имеет свои ограничения. В частности мы можем наследовать только
         * от одного класса, в отличии, например, от языка С++, где имеется множественное наследование.
         * В языке Java подобную проблему частично позволяют решить интерфейсы. Интерфейсы определяют
         * некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы, применяющие
         * эти интерфейсы. И один класс может применить множество интерфейсов.
         *
         * Чтобы определить интерфейс, используется ключевое слово interface.
         *
         *
         *
         *
         */

        /**
         * В данном случае класс Book реализует интерфейс Printable. При этом надо учитывать,
         * что если класс применяет интерфейс, то он должен реализовать все методы интерфейса,
         * как в случае выше реализован метод print. Потом в методе main мы можем создать объект
         * класса Book и вызвать его метод print.
         *
         * Если класс не реализует какие-то методы интерфейса,
         * то такой класс должен быть определен как абстрактный, а его неабстрактные классы-наследники
         * затем должны будут реализовать эти методы.
         *
         * Важно понимать что мы не может создать объекты ни интерфейса, ни абстрактного класса.
         * Такой код не верный:
         *      Printable pr = new Printable();
         *      pr.print();
         */

        Book b1 =new Book("Джава полное руко-во", "Герберт");
                b1.print();
        System.out.println();
        /**
         * 4. Класс Book и класс Journal связаны тем, что они реализуют интерфейс Printable.
         * Поэтому мы динамически в программе можем создавать объекты Printable как экземпляры обоих классов
         *
         * Все сказанное в отношении преобразования типов характерно и для интерфейсов. Например, так как класс
         * Journal реализует интерфейс Printable, то переменная типа Printable может хранить ссылку на объект типа
         * Journal
         */
                Printable printable = new Book("Java","Гербер");
                printable.print();
                printable = new Jurnal("Java 9");
                printable.print();

                //интерфейсы в преобразованиях типов
/**
 * 5. И если мы хотим обратиться к методам класса Journal, которые определены не в интерфейсе Printable,
 * а в самом классе Journal, то нам надо явным образом выполнить преобразование типов: ((Journal)p).getName();
 */

        String name =((Jurnal)printable).getName();

        //здесь  после преобз можно вызвать метод выше нельзя, ниже тип журнал
        ((Jurnal) printable).getName();

        System.out.println(name);
        //методы по умолчанию
        /**
         * Ранее до JDK 8 при реализации интерфейса мы должны были обязательно реализовать все его методы в классе.
         * А сам интерфейс мог содержать только определения методов без конкретной реализации.
         *
         * В JDK 8 была добавлена такая функциональность как методы по умолчанию. И теперь интерфейсы кроме
         * определения методов могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий
         * данный интерфейс, не реализует метод. Например, создадим метод по умолчанию в интерфейсе Printable
         *
         */
//        printable.printDefault();

        //статические методы
        /**
         * 7. Начиная с JDK 8 в интерфейсах доступны статические методы - они аналогичны методам класса
         */
//        Printable.read();



    }
}
